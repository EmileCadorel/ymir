import std.math;
import std.algorithm;

def opTest ('>') (a : int, b : string) : bool {
    return true;
}

def opEquals (a : string, b : string) {
    if (a.length != b.length) return false;
    for (it in 0UL .. a.length)
	if (a [it] != b [it]) return false;
    return true;
}

def opIndex (str : string) : [char] {
    return cast:[char] (str);
}

def opTest ('>') (a : string, b : string) {
    for (it in 0UL .. min (a.length, b.length)) {
	if (a [it] < b [it]) return false;
	else if (a [it] > b [it]) return true;
    }
    return false;
}    

def opTest ('<') (a : string, b : string) {
    for (it in 0UL .. min (a.length, b.length)) {
	if (a [it] > b [it]) return false;
	else if (a [it] < b [it]) return true;
    }
    return false;
}    

def opTest ('<=') (a : string, b : string) {
    for (it in 0UL .. min (a.length, b.length)) {
	if (a [it] > b [it]) return false;
	else if (a [it] < b [it]) return true;
    }
    return true;
}    

def opTest ('>=') (a : string, b : string) {
    for (it in 0UL .. min (a.length, b.length)) {
	if (a [it] < b [it]) return false;
	else if (a [it] > b [it]) return true;
    }
    return true;
}    

def opBinary ('+') (a : string , b : char) {
    return a + cast:string ([b]);
}

private def creator () {
    let useless = "a" + 'b';
    let b = "a" < "b";
}

def getArgs (argc, argv) : [string] {
    let ret = [string; 0UL];
    for (it in 0 .. argc) {
	ret += [(*(argv + (it * 8))).to!string];
    }
    return ret;
}

