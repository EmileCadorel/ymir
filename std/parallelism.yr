import std.stdio;
import std.conv;
import std.traits;
import std.array;

def pipe (ref a : [int]) : int {
    extern (C) pipe (a : ptr!int) : int;
    import std.stdio;
    if (a.length != 2UL) {
	a = [int; 2UL];
    }
    return pipe (a.ptr);
}

enum
| LOCK_SH : 1
| LOCK_EX : 2
| LOCK_UN : 8
-> Locks;

extern (C) close (a : int);
extern (C) open (a : int);
extern (C) read (a : int, msg : ptr!void, len : int);
extern (C) write (a : int, msg : ptr!void, len : int);
extern (C) flock (int, int);

def read (desc : int, ref msg : string) {
    let len = 0UL;
    read (desc, cast:ptr!(void) (&len), cast:int(ulong.sizeof));
    let ret = cast:string ([char; len]);    
    read (desc, cast:ptr!(void) (ret.ptr), cast:int(len));
    msg = ret;
}

def read if (is (T : string))
    (T) (desc : int) {
	let len = 0UL;
	read (desc, cast:ptr!(void) (&len), cast:int(ulong.sizeof));
	if (len == 0UL) return '';
	let ret = [char; len];    
	read (desc, cast:ptr!(void) (ret.ptr), cast:int(len));
	return cast:string (ret);
    }

def read if (isArray!(T)())
    (T) (desc : int) {
	let len = 0UL;
	read (desc, cast:ptr!(void) (&len), cast:int(ulong.sizeof));
	extern (C) read (a : int, msg : ptr!void, len : int);
	let ret = [T; len];
	read (desc, cast:ptr!(void) (ret.ptr), cast:int(len) * cast:int (T.sizeof));
	return cast:T (ret);
}

def read (T) (desc : int, ref msg : [T]) {
    let len = 0UL;
    read (desc, cast:ptr!(void) (&len), cast:int(ulong.sizeof));
    if (len == 0UL) msg = null;
    let ret = [T; len];
    read (desc, cast:ptr!(void) (ret.ptr), cast:int(len) * cast:int (T.sizeof));
    msg = ret;
}

def read if (!is (T : string) && !is (T : struct) && !isArray!(T)())
    (T) (desc : int) : T {
	let msg = [ubyte; T.sizeof];
	read (desc, cast:ptr!(void) (msg.ptr), cast:int(T.sizeof));
	return msg.ptr.T;
    }

def write if (is(T : string))
    (T) (desc : int, msg) {
	let len = msg.length;
	write (desc, cast:ptr!(void) (&len), cast:int(ulong.sizeof));
	write (desc, cast:ptr!(void) (msg.ptr), cast:int(msg.length));	
    }

def write (T) (desc : int, msg : [T]) {
    let len = msg.length;
    write (desc, cast:ptr!(void) (&len), cast:int(ulong.sizeof));
    if len != 0UL
	write (desc, cast:ptr!(void) (msg.ptr), cast:int(msg.length * T.sizeof));
}

def write if (!is (T : string) && !is (T : struct) && !isArray!(T) ())
    (T) (desc : int, msg : T) {
	write (desc, cast:ptr!(void) (&msg), cast:int(T.sizeof));
    }

def write if (isTuple !(T) ())
    (T) (desc : int, elem : T) {
	write (desc, cast:ptr!(void) (elem.ptr), cast:int(T.sizeof));
    }


def bufferize if (is (T : string))
    (T) (a : T) {
	let buf = [ubyte; 8UL];
	buf.ptr.ulong = a.length;
	return buf + to!([ubyte]) (a);
    }

def bufferize if (isPrimitive!(T) ())
    (T) (elem : T) {
	let buf = [ubyte; T.sizeof];
	buf.ptr.T = elem;
	return buf;
    }

def bufferize if (isArray!(T) ())
    (T) (elem : T) {
	let buf = [ubyte; 8UL];
	buf.ptr.ulong = elem.length;
	return buf + cast:[ubyte] (elem);
    }

def writeTuple (fst) {
    static if (isTuple!(typeof(fst)) ()) {
	return writeTuple (expand (fst));
    } else {
	return bufferize !(typeof(fst)) (expand (fst));
    }
}

def writeTuple (fst, next) {
    let ret;
    static if (isTuple!(typeof (fst)) ()) {
	ret = writeTuple (expand (fst));
    } else {
	ret = bufferize !(typeof(fst)) (fst);
    }
    return ret + writeTuple (expand (next));
}

def readTuple (T) (desc : int, fst : T) {
    static if (isTuple!(typeof (fst)) ()) {
	return readTuple (desc, expand (fst));
    } else {
	return read !(typeof (fst)) (desc);
    }
}

def readTuple (T) (desc : int) {
    return read !(T) (desc);
}

def readTuple (T) (desc : int, fst : T, next) {
    static if (isTuple!(typeof (fst)) ()) {
	return (
	    expand (readTuple (desc, expand (fst))),
	    expand (readTuple (desc, expand (next)))
	);
    } else {
	return (read !(typeof(fst))(desc), expand (readTuple (desc, expand (next))));
    }
}

def send (T) (desc : int, i : int, what : T) {    
    let name = what.typeid;
    let nameLen = name.length;
    let buf = writeTuple (expand (what));	
    let len = buf.length + name.length + (int.sizeof) + (ulong.sizeof);
    flock (desc, Locks::LOCK_EX);
    write (desc, cast:ptr!(void) (&len), cast:int (ulong.sizeof));
    write (desc, cast:ptr!(void) (&i), cast:int (int.sizeof));
    write (desc, cast:ptr!(void) (&nameLen), cast:int (ulong.sizeof));
    write (desc, cast:ptr!(void) (name.ptr), cast:int (name.length));
    write (desc, cast:ptr!(void) (buf.ptr), cast:int (buf.length));
    flock (desc, Locks::LOCK_UN);
}

def recv if (isTuple!(T) ())
    (T) (desc : int, a : T)  {       
	let len = 0UL;
	read (desc, cast:ptr!(void) (&len), cast:int (len.sizeof));
	if (len != T.sizeof) assert (false, to!(string) (len) + ' ' + to!(string) (cast:int(T.sizeof)));
	read (desc, a.ptr, cast:int(T.sizeof));
    }

def receive (desc : int, foos) {
    let type = '';
    read (desc, type);
    
    def callTuple (desc : int, name : string, foo) {
	static if (isTuple!(typeof (foo.paramTuple)) ()) {
	    let t = foo.paramTuple.empty;
	    let n = t.typeid;
	    if (n == name) {
		let aux = readTuple (desc, expand (t));
		foo (expand (aux));
	    } else assert (false);
	} else {
	    let n = foo.paramTuple.typeid;
	    if (n == name) {
		let aux = readTuple !(typeof (foo.paramTuple)) (desc);
		foo (expand (aux));
	    } else assert (false);
	}
    }
    
    def callTuple (desc : int, name : string, foo, foos) {
	static if (isTuple!(typeof (foo.paramTuple)) ()) {
	    let t = foo.paramTuple.empty;
	    let n = t.typeid;
	    if (n == name) {
		let aux = readTuple (desc, expand (t));
		foo (expand (aux));
	    } else callTuple (desc, name, expand (foos));
	} else {
	    let n = foo.paramTuple.typeid;
	    if (n == name) {
		let aux = readTuple !(typeof (foo.paramTuple)) (desc);
		foo (expand (aux));
	    } else callTuple (desc, name, expand (foos));
	}
    }

    callTuple (desc, type, expand (foos));    
}

def joinAll (a : [int]) {
    extern (C) wait (pid : int, a : ptr!int, int);
    import std.traits;
    
    for (it in 1UL .. a.length) {
	let stat = int.init;
	wait (a [it], &stat, 0);
    }
    write (a [0], -1); 
}

def spawn (nb : ulong, call : fn (ulong, ulong, [int])->int) : [int] { 
    extern (C) fork () : int;
    extern (C) exit (int);
    extern (C) getpid () : int;
    let desc = [int; nb], pids = [int; nb];
    let c2p = [0, 0];
    pipe (c2p);
    for (it in 1UL .. (nb + 1UL)) {
	let p2c = [0, 0];
	pipe (p2c);
	
	let a = fork ();
	if (a == 0) {
	    close (c2p [0]);
	    close (p2c [1]);
	    exit (call (it, nb, [p2c [0], c2p [1]]));
	} else {
	    pids [it - 1UL] = a;
	    close (p2c [0]);
	    desc [it - 1UL] = p2c [1];
	}
    }
    
    let pid = fork ();
    if (pid == 0) {
	close (c2p [1]);    
	exit (spawnRoutine (nb, c2p [0], desc));
    } else 
	close (c2p [0]);
    
    return [c2p [1]] + pids;
}

private def spawnRoutine (nb : ulong, _in : int, desc : [int]) : int {
    import std.conv;
    let msg = [ubyte ; 0UL];
    while (true) {
	read (_in, msg);
	if ((msg.ptr + 0).int == -1) break;
	else {	    
	    let to_ = (msg.ptr + 0).int;
	    let aux = msg [4UL .. msg.length];
	    write (desc [to_ - 1], cast:ptr!void (aux.ptr), cast:int (aux.length));
	}
    }
    return 0;
}
