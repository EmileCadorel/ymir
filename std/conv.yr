public import std.traits;

def to if (is (T : string)) 
    (T)  (c : char) : string 
	return cast:string ([c]);

def to if (is (T : string))
    (T, c : char) () {
	return '' + c;
    }

def to if (is (T : string))
    (T)  (a : ptr!char) : string {
	if (a is null) return '';
	else if (*a == 0ub) return ''; 
	let ret = [*a];
	a = a + 1;
	while (*a != 0ub) {
	    ret += [*a];
	    a = a + 1;
	}
	return cast:string (ret);
    }

def to if (is (T : string))
    (T) (elem : [char]) : string {
	return cast:string (elem);
    }

def to if (is (T : string) && (is (T2 : long) || is (T2 : int)))
    (T, T2) (elem : T2) : string {
	import std.traits;
	if (elem < 0) return "-" + to!(T) (-elem);
	else if (elem == 0) return "0";
	let nb = elem, size = 0UL;
	while (nb > 0) { nb /= to!(T2) (10B); size ++; }       
	let res = [char ; size];	
	for (it in 0UL .. size) {
	    res [size - it - 1UL] = cast:char ((elem % to!(T2) (10UB))) + '0';
	    elem /= to!(T2) (10UB);
	}	
	return cast:string (res);
    }

def to if (is (T : string) && is (T2 : short))
    (T, T2) (elem : T2) : string {
	import std.traits;
	return to!(string) (cast:int(elem));
    }

def to if (is (T : string) && is (T2 : byte))
    (T, T2) (elem : T2) : string {
	let aux = cast:int (elem);
	let right = aux % 16;
	let left = aux / 16;
	let ret = [char; 2UL];
	
	if (right <= 9) ret [1] = cast:char (right) + '0';
	else ret [1] = cast:char (right - 10) + 'a';

	if (left <= 9) ret [0] = cast:char (left) + '0';
	else ret [0] = cast:char (left - 10) + 'a';
	return cast:string (ret);
    }

def to if (isDecimal!(T)())
    (T) (elem : string) : T {
	import std.conv;
	let res = T.init;
	for (it in 0UL .. elem.length) {
	    let current = elem [it];	    
	    if (current >= '0' && current <= '9') {
		res *= cast:T(10UB);
		res += cast:T (current - '0');
	    } else assert (false, to!(string) (current));
	}
	return res;
    }

def to if (is (T : string) && isUnsigned!(T2)())
    (T, T2) (elem : T2) : string {
	return to!(string) (toSigned (elem));
    }

def toSigned if (isUnsigned!(T)()) 
    (T) (elem : T) {
	static if (is (T : ulong)) return cast:long (elem);
	else if (is (T : uint)) return cast:int (elem);
	else if (is (T : ushort)) return cast:short (elem);
	else return cast:byte (elem);	
    }

def to if (isDecimal!(T)() && isDecimal!(T2) ())
    (T, T2) (elem : T2) {
	static if (is (T : T2)) return elem;
	else return cast:T (elem);
    }

def to if (is (T : string))
    (T, T2) (elem : [T2]) {
	if (elem is null) return 'null';
	else {
	    let ret = "[";
	    for (it in 0UL .. elem.length) {
		ret += to!(string) (elem [it]);
		if (it != elem.length - 1UL)
		    ret += ", ";
	    }	
	    ret += "]";
	    return ret;
	}
    }

def to if (is (T : string))
    (T) (elem : T) {
	if (elem is null) return 'null';
	else return elem;
    }

def addTupleComa if (!isTuple!(T)())
    (T) (left : T) : string {
	return to!(string) (left);
    }

def addTupleComa (T) (left : T, elem) : string {
    static if (!isPrimitive!(typeof (elem))() && !isTuple!(typeof (elem))()) {
	if (elem !is null)
	    return to!(string)(left) + ", " + addTupleComa (expand (elem));
	else
	    return to!(string)(left) + ", null";
    } else {
	return to!(string) (left) + ", " + addTupleComa (expand (elem));
    }
}

def to if (is (T : string) && isTuple!(T2) ())
    (T, T2) (elem : T2) : string {	
	return 'tuple(' + addTupleComa (expand (elem)) + ')';	
    }

def to if (is (T : string) && is (T2 : struct))
    (T, T2) (elem : T2) {
	if (elem is null) return T2.typename;	
	else return T2.typename + "(" + addTupleComa (expand (elem.tupleof)) + ")";
    }

def to if (is (T : [ubyte]))
    (T) (a : string) {
	let res = [ubyte; a.length];
	for (it in 0UL .. a.length) {
	    res [it] = cast:ubyte (a[it]);
	}
	return res;
    }

	



