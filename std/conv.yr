public import std.traits;

def to if (is (T : string)) 
    (T)  (c : char) : string 
	return cast:string ([c]);

def to if (is (T : string))
    (T, c : char) () {
	return '' + c;
    }

def to if (is (T : string))
    (T)  (a : ptr!char) : string {
	if (a is null) return '';
	else if (*a == 0ub) return ''; 
	let ret = [*a];
	a = a + 1;
	while (*a != 0ub) {
	    ret += [*a];
	    a = a + 1;
	}
	return cast:string (ret);
    }

def to if (is (T : string))
    (T) (elem : [char]) : string {
	return cast:string (elem);
    }

def to if (is (T : string) && isSigned!(T2)() && !is (T2 : byte))
    (T, T2) (elem : T2) : string {
	if (elem < 0) return "-" + to!(T) (-elem);
	else if (elem == 0) return "0";
	let nb = elem, size = 0UL;
	while (nb > 0) { nb /= to!(T2) (10B); size ++; }       
	let res = [char ; size];
	
	for (it in size .. 0UL) {
	    res [it - 1UL] = cast:char ((elem % to!(T2) (10UB))) + '0';
	    elem /= to!(T2) (10UB);
	}	
	return cast:string (res);
    }

def to if (is (T : string) && is (T2 : byte))
    (T, T2) (elem : T2) : string {
	let aux = cast:int (elem);
	let right = aux % 16;
	let left = aux / 16;
	let ret = [char; 2UL];
	
	if (right <= 9) ret [1] = cast:char (right) + '0';
	else ret [1] = cast:char (right - 10) + 'a';

	if (left <= 9) ret [0] = cast:char (left) + '0';
	else ret [0] = cast:char (left - 10) + 'a';
	return cast:string (ret);
    }

def to if (is (T : string) && isUnsigned!(T2)())
    (T, T2) (elem : T2) : string {
	return to!(string) (toSigned (elem));
    }

def toSigned if (isUnsigned!(T)()) 
    (T) (elem : T) {
	static if (is (T : ulong)) return cast:long (elem);
	else if (is (T : uint)) return cast:int (elem);
	else if (is (T : ushort)) return cast:short (elem);
	else return cast:byte (elem);	
    }

def to if (isDecimal!(T)() && isDecimal!(T2) ())
    (T, T2) (elem : T2) {
	static if (is (T : T2)) return elem;
	else return cast:T (elem);
    }

def to if (is (T : string))
    (T, T2) (elem : [T2]) {
	let ret = "[";
	for (it in 0UL .. elem.length) {
	    ret += to!(string) (elem [it]);
	    if (it != elem.length - 1UL)
		ret += ", ";
	}	
	ret += "]";
	return ret;
    }

def addTupleComa (left) {
    return to!(string) (left);
}

def addTupleComa (left, elem) {
    return to!(string)(left) + ", " + addTupleComa (expand (elem));
}

def to if (is (T : string) && isTuple!(T2) ())
    (T, T2) (elem : T2) {		
	return 'tuple(' + addTupleComa (expand (elem)) + ')';	
    }

def to if (is (T : string) && is (T2 : struct))
    (T, T2) (elem : T2) {
	return T2.typename + "(" + addTupleComa (expand (elem.tupleof)) + ")";
    }

	



