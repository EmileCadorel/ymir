import std.stdio;
import std.math;

def resize (T) (a : ref!([T]), len : ulong) {
    let aux = [T; len];
    if (len < a.length)
	for (it in 0ul .. len) aux [it] = a [it];
    else
	for (it in 0ul .. a.length) aux [it] = a[it];              
    a = aux;
}

def cresize (T) (a : ref!([T]), len : ulong) {
    let aux = [int; len];
    if (len < a.length) {
	for (it in 0ul .. len)
	    aux [it] = a [it];
    } else {
	for (it in 0ul .. a.length) aux [it] = a[it];       	
	for (it in (a.length) .. len) aux [it] = int.init;
    }    
    a = aux;
}

def insertBack (T) (a : ref!([T]), elem : T) {
    let aux = [T; a.length + 1u];
    for (it in 0ul .. a.length)
	aux [it] = a [it];
    aux [a.length] = elem;
    a = aux;
}

def removeBack (T) (a : ref!([T])) : T {
    let ret = a [a.length - 1u];
    a.resize (a.length - 1u);
    return ret;
}

def dup (T) (a : [T]) : [T] {
    let aux = [T; a.length];
    for (it in 0ul .. aux.length)
	aux [it] = a [it];
    return aux;
}

def print (T) (a : [T]) {
    print ('[');
    for (it in 0ul .. a.length) {
	print (a [it]);
	if (it < a.length - 1ul) print (', ');
    }
    print (']');
}

def back (T) (a : [T]) : T {
    return a [a.length - 1ul];
}

def front (T) (a : [T]) : T {
    return a [0];
}

def tail (T) (a : [T]) : [T] {
    //if (a.length == 0UL) return [T; 0UL];
    return a [1UL .. a.length];
}

def clear (T) (a : ref!([T])) {
    a = [T; 0ul];
}

def slice (T) (a : [T], fst : long, scd : ulong) : [T] {
    import std.math;
    let size = abs (cast:long (scd) - fst);
    let ret = [T; cast:ulong (size)];
    let index = 0ul;
    for (it in fst .. cast:long(scd)) {
	ret [index] = a [it];
	index ++;
    }
    return ret;
}

def slice (T) (a : [T], fst : long, scd : long) : [T] {
    import std.math;
    let size = abs (scd - fst);
    let ret = [T; cast:ulong (size)];
    let index = 0ul;
    for (it in fst .. scd) {
	ret [index] = a [it];
	index ++;
    }
    return (ret);
}

def opIndex (T, T2) (a : [T], ind : range!T2) : [T] {    
    return slice (a, cast:long (ind.fst), (ind.scd));
}

def opIndex (T) (a : [T], ind : int, left : int) : [T] {
    return [a [ind], a [left]];
}

def opIndex (T) (a : [T], ind : int, left) : [T] {
    return [a [ind]] + a [expand (left)];
}
